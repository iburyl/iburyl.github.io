<!DOCTYPE html>
<html>
<head>
   <meta charset="UTF-8">

   <style>
        table, th, td {
          border: 1px solid;
        }
table {
  border-collapse: collapse;
}

div#detail_div {
  position: fixed;
  top: 0;
  right: 0;
}

div#detail_div canvas {
  width: 500px;
  height: 300px;
}

   </style>
</head>
<body>

   <form id="myForm">
      <input type="file" id="csvFile" accept=".csv" />
      <br /><br />
      <input type="submit" value="Get accumulating years" />
      <br /><br />
   </form>

<div id="instruction">
<h3>Instruction:</h3>
Any options here, then press red-circled link.<br />
   <img width=600 src="img/first.jpeg" /><br /><br />
Green-circled options are required, red-circled options should be avoided (the issues with those are fixed, but be cautious just in case).<br />
   <img width=600 src="img/second.png" /><br /><br />
Waiting for archive to be available.<br />
Download archive, unpack it...<br />
Provide results CSV file to the form:<br />
</div>

   <div id="detail_div"></div>
   <table id="table_years"></table>

<script src="https://cdn.jsdelivr.net/npm/chart.js"></script>
<script type="text/javascript">
    // Source for this one is: https://www.bennadel.com/blog/1504-ask-ben-parsing-csv-strings-with-javascript-exec-regular-expression-command.htm
    // https://stackoverflow.com/questions/1293147/how-to-parse-csv-data
	
    // This will parse a delimited string into an array of
	// arrays. The default delimiter is the comma, but this
	// can be overriden in the second argument.
	function CSVToArray( strData, strDelimiter ){
		// Check to see if the delimiter is defined. If not,
		// then default to comma.
		strDelimiter = (strDelimiter || ",");

		// Create a regular expression to parse the CSV values.
		var objPattern = new RegExp(
			(
				// Delimiters.
				"(\\" + strDelimiter + "|\\r?\\n|\\r|^)" +

				// Quoted fields.
				"(?:\"([^\"]*(?:\"\"[^\"]*)*)\"|" +

				// Standard fields.
				"([^\"\\" + strDelimiter + "\\r\\n]*))"
			),
			"gi"
			);


		// Create an array to hold our data. Give the array
		// a default empty first row.
		var arrData = [[]];

		// Create an array to hold our individual pattern
		// matching groups.
		var arrMatches = null;


		// Keep looping over the regular expression matches
		// until we can no longer find a match.
		while (arrMatches = objPattern.exec( strData )){

			// Get the delimiter that was found.
			var strMatchedDelimiter = arrMatches[ 1 ];

			// Check to see if the given delimiter has a length
			// (is not the start of string) and if it matches
			// field delimiter. If id does not, then we know
			// that this delimiter is a row delimiter.
			if (
				strMatchedDelimiter.length &&
				(strMatchedDelimiter != strDelimiter)
				){

				// Since we have reached a new row of data,
				// add an empty row to our data array.
				arrData.push( [] );

			}


			// Now that we have our delimiter out of the way,
			// let's check to see which kind of value we
			// captured (quoted or unquoted).
			if (arrMatches[ 2 ]){

				// We found a quoted value. When we capture
				// this value, unescape any double quotes.
				var strMatchedValue = arrMatches[ 2 ].replace(
					new RegExp( "\"\"", "g" ),
					"\""
					);

			} else {

				// We found a non-quoted value.
				var strMatchedValue = arrMatches[ 3 ];

			}


			// Now that we have our value string, let's add
			// it to the data array.
			arrData[ arrData.length - 1 ].push( strMatchedValue );
		}

		// Return the parsed data.
		return( arrData );
	}

</script>

<script>

function CSV2Observations(string)
{
    const CSVarrays = CSVToArray(string);
    
    var headers = CSVarrays[0];
    CSVarrays.shift();

    const knownHeaderName = [ "user_login",  "url", "time_observed_at", "scientific_name", "common_name", "quality_grade", "observed_on", "id"];
    let   knownHeaderIdx  = [];
    
    for (let i = 0; i < headers.length; i++) {
        for (let j = 0; j < knownHeaderName.length; j++) {
            if(headers[i] == knownHeaderName[j]) {
                knownHeaderIdx[j] = i;
            }
        }
    }
    const i_user_login   =knownHeaderIdx[0];
    const i_url          =knownHeaderIdx[1];
    const i_time_observed=knownHeaderIdx[2];
    const i_lat_name     =knownHeaderIdx[3];
    const i_lang_name    =knownHeaderIdx[4];
    const i_quality_grade=knownHeaderIdx[5];
    const i_observed_on  =knownHeaderIdx[6];
    const i_id           =knownHeaderIdx[7];
    console.log(knownHeaderIdx);

    let observations = [];

    console.log('Total observations: ' + CSVarrays.length);

    for(let i = 0; i < CSVarrays.length; i++) {
        const values = CSVarrays[i];

        let lat_name = values[i_lat_name];
        let observed_time = (values[i_time_observed] != '') ? new Date(values[i_time_observed]) : new Date(values[i_observed_on]);

        if(values.length == 1)
        {
            break;
        }
        if(values.length != headers.length)
        {
            console.log(values);
            console.log("broken line");
            continue;
        }
        
        let lat_name_split = lat_name.split(" ");
        
        let is_identified = (lat_name_split.length >= 2);
        if(!is_identified) continue;

        let is_hybrid = false;
        if( (lat_name_split.length == 3 && lat_name_split[1].length == 1) || lat_name_split.length > 3 )
        {
            is_hybrid = true;
        }
        
        let is_ssp = false;

        if(lat_name_split.length > 2 && !is_hybrid)
        {
            is_ssp = true;
            lat_name = lat_name_split[0] + ' ' + lat_name_split[1]; // remove subspecies
        }

        let is_research = (values[i_quality_grade] == "research");

        let obs = {
            obs_id: values[i_id],
            user_id: values[i_user_login],
            name: values[i_lang_name],
            lat_name_sp: lat_name,
            lat_name: values[i_lat_name],
            time: observed_time,
            url: values[i_url],
            is_research: is_research,
            is_ssp: is_ssp,
            is_hybrid: is_hybrid,
        };

        if (is_ssp)
        {
            obs.lat_name_ssp = Array.from(lat_name_split[0])[0] + '.' + Array.from(lat_name_split[1])[0] + '. ' + lat_name_split[2];
        }

        observations.push(obs);
    }

    return observations;
}

function Observations2SpeciesMap(observations)
{
    const speciesMap = new Map();

    observations.forEach((obs) => {
        
        let card;
        
        if( !speciesMap.has(obs.lat_name_sp) )
        {
            card = {
                lat_name: obs.lat_name_sp,
                name: obs.name,
                total_observed: 0,
                total_research: 0,
                first_observed: obs,
                last_observed:  obs,
                ssps: new Map(),
                observations: new Array(),
            };

            speciesMap.set(obs.lat_name_sp, card);
        }
        else
        {
            card = speciesMap.get(obs.lat_name_sp);
        }

        card.observations.push( obs );
        card.total_observed += 1;
        card.total_research += (obs.is_research)?1:0;

        if( !obs.is_hybrid && !obs.is_ssp && card.name != obs.name )
        {
            card.name = obs.name;
        }

        
        if( obs.time < card.first_observed.time )
        {
            card.first_observed = obs;
        }

        if( obs.time > card.last_observed.time )
        {
            card.last_observed = obs;
        }

        if( obs.is_research )
        {
            if( typeof card.first_research === "undefined" || obs.time < card.first_research.time )
            {
                card.first_research = obs;
            }
        }

        if( obs.is_ssp )
        {
            if( card.ssps.has(obs.lat_name_ssp) )
            {
                num = card.ssps.get(obs.lat_name_ssp);
                num += 1;
                card.ssps.set(obs.lat_name_ssp, num);
            }
            else
            {
                card.ssps.set(obs.lat_name_ssp, 1);
            }
        }
    } );

    console.log('Total species: ' + speciesMap.size);

    return speciesMap;
}

</script>

<script>

function getCardTdSummary( card )
{
    let name = card.name;
    let lat_name = document.createElement("span");

    lat_name.addEventListener("click", (event) => {
        generateSpeciesDetail( card );
    });

    lat_name.innerHTML = card.lat_name;
    let total    = card.total_observed;
    let research = card.total_research;

    let fst_url  = card.first_observed.url;
    let fst_href = `<a href='${fst_url}'>link</a>`;
    let fst_user = card.first_observed.user_id;

    let lst_url  = card.last_observed.url;
    let lst_href = `<a href='${lst_url}'>link</a>`;
    let lst_year = card.last_observed.time.getFullYear();


    let first_is_research = card.first_observed.is_research;
    let has_research = typeof card.first_research !== "undefined";
    let rsch_url  = (first_is_research)?'':(!has_research)?'':card.first_research.url;
    let rsch_href = (first_is_research)?'':(!has_research)?'':`<a href='${rsch_url}'>link</a>`;
    let rsch_user = (first_is_research)?'':(!has_research)?'':card.first_research.user_id;
    let rsch_year = (first_is_research)?'':(!has_research)?'none':card.first_research.time.getFullYear();

    let ssps_text = '';
    if( card.ssps.size > 0 )
    {
        card.ssps.forEach( (num, ssp) => 
        {
            ssps_text += ssp + ' - ' + num + '<br/>';
        });
    }

    return [name, lat_name, total, research, ssps_text, fst_href, fst_user, rsch_year, rsch_href, rsch_user];
}

function generateYearsTable( speciesMap )
{
    const speciesYearsMap = new Map();

    speciesMap.forEach( (value, key) =>
    {
        const card = value;
        let year = card.first_observed.time.getFullYear();

        if( !speciesYearsMap.has(year) )
        {
            speciesYearsMap.set(year, []);
        }

        speciesYearsMap.get(year).push(value);
    } );

    const speciesYearsMapSorted = new Map([...speciesYearsMap].sort());

    {
        const instruction = document.getElementById("instruction");
        instruction.innerHTML = '';
        const table_years = document.getElementById("table_years");
        table_years.innerHTML = '';

        table_years.appendChild(createTr(
                   [['rowspan',2,'year'], ['colspan',2,'number of species'], ['colspan',2,'names'], ['colspan',3,'all years'],
                    ['colspan',2,'first observation'],
                    ['colspan',3,'first research grade if different']]));

        table_years.appendChild(createTr(
                   ['cumulative', 'this year', 'common', 'latin (clickable)', 'obs', 'rsch','ssps',
                    'ref', 'user', 'year', 'ref', 'user']));

        let cumulative = 0;
        speciesYearsMapSorted.forEach( (cards, year) =>
        {
            cumulative += cards.length;

            let first = true;

            cards.forEach( (card) => 
            {
                let tdFileds = getCardTdSummary( card );
                
                if(first)
                {
                    let prefixTdFiled = [['rowspan',cards.length, year], ['rowspan', cards.length, cumulative], ['rowspan', cards.length, cards.length]];
                    tdFileds = prefixTdFiled.concat(tdFileds);
                }

                table_years.appendChild( createTr( tdFileds ) );
                
                first = false;
            } );
        } );
    }
}

</script>

<script>

function generateSpeciesDetail( card )
{
    let monthsN = [0,0,0, 0,0,0, 0,0,0, 0,0,0]; 
    let yearsMap = new Map();

    card.observations.forEach(( obs ) => 
    {
        monthsN[ obs.time.getMonth() ] += 1;

        let year = obs.time.getFullYear();
        let year_value = 1;

        if( yearsMap.has(year) )
        {
            year_value = yearsMap.get(year) + 1;
        }

        yearsMap.set(year, year_value);
    } );

    yearsMap = new Map([...yearsMap].sort());

    const detail_div = document.getElementById("detail_div");
    detail_div.innerHTML = card.name + ' (' + card.lat_name + ')';

    let monthGraphCanvas = document.createElement("canvas");
    detail_div.appendChild( monthGraphCanvas );

    detail_div.appendChild( document.createElement("br") );

    let yearGraphCanvas = document.createElement("canvas");
    detail_div.appendChild( yearGraphCanvas );

    new Chart(monthGraphCanvas, {
        type: 'bar',
        data: {
          labels: ['J', 'F', 'M', 'A', 'M', 'J', 'J', 'A', 'S', 'O', 'N', 'D'],
          datasets: [{
            label: '#',
            data: monthsN,
            borderWidth: 1
          }]
        },
        options: {
          scales: {
            y: { beginAtZero: true }
          }
        }
      });

    new Chart(yearGraphCanvas, {
        type: 'bar',
        data: {
          labels: [ ...yearsMap.keys() ],
          datasets: [{
            label: '#',
            data: [ ...yearsMap.values() ],
            borderWidth: 1
          }]
        },
        options: {
          scales: {
            y: { beginAtZero: true }
          }
        }
      });

}

</script>

   
<script>
   function createTr(tdArray) {
     let tr = document.createElement("tr");

     for (var i = 0; i < tdArray.length; i++) {
         let td = document.createElement("td");
         
         if( tdArray[i] instanceof HTMLElement )
         {
             td.appendChild( tdArray[i] );
         }
         else if( Array.isArray(tdArray[i]) )
         {
             td.setAttribute(tdArray[i][0], tdArray[i][1]);
             td.innerHTML = tdArray[i][2];
         }
         else
         {
             td.innerHTML = tdArray[i];
         }
         
         tr.appendChild( td );
     }

     return tr;
   }
   
   const myForm = document.getElementById("myForm");
   const csvFile = document.getElementById("csvFile");
   myForm.addEventListener("submit", function (e) {
      console.log(e.submitter.getAttribute("value"));

      e.preventDefault();
      const input = csvFile.files[0];
      const reader = new FileReader();
      reader.onload = function (e) {
         const string = e.target.result;

         const observations = CSV2Observations(string);
         const speciesMap = Observations2SpeciesMap(observations);

         generateYearsTable( speciesMap );
         
      };
      reader.readAsText(input);

   });
</script>
</body>
</html>
