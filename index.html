<!DOCTYPE html>
<html>
<head>
   <meta charset="UTF-8">

   <style>
        table, th, td {
          border: 1px solid;
        }
table {
  border-collapse: collapse;
}

div#output {
  position: fixed;
  top: 0;
  right: 0;
}

div#output canvas {
  width: 500px;
  height: 300px;
}

   </style>
</head>
<body>

<div id="instruction">
Any options here, then press red-circled link.<br />
   <img width=600 src="img/first.jpeg" /><br /><br />
Green-circled options are required, red-circled options should be avoided (the issues with those are fixed, but be cautious just in case).<br />
   <img width=600 src="img/second.png" /><br /><br />
Waiting for archive to be available.<br />
Download archive, unpack it...<br />
Provide results CSV file to the form:<br />
</div>

   <form id="myForm">
      <input type="file" id="csvFile" accept=".csv" />
      <br />
      <input type="submit" value="Process" />
   </form>

   <div id="output"></div>
   <table id="table_years"></table>

<script src="https://cdn.jsdelivr.net/npm/chart.js"></script>
<script type="text/javascript">
    // Source for this one is: https://www.bennadel.com/blog/1504-ask-ben-parsing-csv-strings-with-javascript-exec-regular-expression-command.htm
    // https://stackoverflow.com/questions/1293147/how-to-parse-csv-data
	
    // This will parse a delimited string into an array of
	// arrays. The default delimiter is the comma, but this
	// can be overriden in the second argument.
	function CSVToArray( strData, strDelimiter ){
		// Check to see if the delimiter is defined. If not,
		// then default to comma.
		strDelimiter = (strDelimiter || ",");

		// Create a regular expression to parse the CSV values.
		var objPattern = new RegExp(
			(
				// Delimiters.
				"(\\" + strDelimiter + "|\\r?\\n|\\r|^)" +

				// Quoted fields.
				"(?:\"([^\"]*(?:\"\"[^\"]*)*)\"|" +

				// Standard fields.
				"([^\"\\" + strDelimiter + "\\r\\n]*))"
			),
			"gi"
			);


		// Create an array to hold our data. Give the array
		// a default empty first row.
		var arrData = [[]];

		// Create an array to hold our individual pattern
		// matching groups.
		var arrMatches = null;


		// Keep looping over the regular expression matches
		// until we can no longer find a match.
		while (arrMatches = objPattern.exec( strData )){

			// Get the delimiter that was found.
			var strMatchedDelimiter = arrMatches[ 1 ];

			// Check to see if the given delimiter has a length
			// (is not the start of string) and if it matches
			// field delimiter. If id does not, then we know
			// that this delimiter is a row delimiter.
			if (
				strMatchedDelimiter.length &&
				(strMatchedDelimiter != strDelimiter)
				){

				// Since we have reached a new row of data,
				// add an empty row to our data array.
				arrData.push( [] );

			}


			// Now that we have our delimiter out of the way,
			// let's check to see which kind of value we
			// captured (quoted or unquoted).
			if (arrMatches[ 2 ]){

				// We found a quoted value. When we capture
				// this value, unescape any double quotes.
				var strMatchedValue = arrMatches[ 2 ].replace(
					new RegExp( "\"\"", "g" ),
					"\""
					);

			} else {

				// We found a non-quoted value.
				var strMatchedValue = arrMatches[ 3 ];

			}


			// Now that we have our value string, let's add
			// it to the data array.
			arrData[ arrData.length - 1 ].push( strMatchedValue );
		}

		// Return the parsed data.
		return( arrData );
	}

</script>

<script>

function CSV2SpeciesMap(string)
{
    const CSVarrays = CSVToArray(string);
    
    var headers = CSVarrays[0];
    CSVarrays.shift();

    const knownHeaderName = [ "user_login",  "url", "time_observed_at", "scientific_name", "common_name", "quality_grade", "observed_on", "id"];
    let   knownHeaderIdx  = [];
    
    for (let i = 0; i < headers.length; i++) {
        for (let j = 0; j < knownHeaderName.length; j++) {
            if(headers[i] == knownHeaderName[j]) {
                knownHeaderIdx[j] = i;
            }
        }
    }
    const i_user_login   =knownHeaderIdx[0];
    const i_url          =knownHeaderIdx[1];
    const i_time_observed=knownHeaderIdx[2];
    const i_lat_name     =knownHeaderIdx[3];
    const i_lang_name    =knownHeaderIdx[4];
    const i_quality_grade=knownHeaderIdx[5];
    const i_observed_on  =knownHeaderIdx[6];
    const i_id           =knownHeaderIdx[7];
    console.log(knownHeaderIdx);

    const speciesMap = new Map();

    console.log('Total observations: ' + CSVarrays.length);

    for(let i = 0; i < CSVarrays.length; i++) {
        const values = CSVarrays[i];

        let lat_name = values[i_lat_name];
        let observed_time = (values[i_time_observed] != '') ? new Date(values[i_time_observed]) : new Date(values[i_observed_on]);

        if(values.length == 1)
        {
            break;
        }
        if(values.length != headers.length)
        {
            console.log(values);
            console.log("broken line");
            continue;
        }
        
        let lat_name_split = lat_name.split(" ");
        
        let is_identified = (lat_name_split.length >= 2);
        if(!is_identified) continue;

        let is_hybrid = false;
        if( (lat_name_split.length == 3 && lat_name_split[1].length == 1) || lat_name_split.length > 3 )
        {
            is_hybrid = true;
        }
        
        let is_ssp = false;

        if(lat_name_split.length > 2 && !is_hybrid)
        {
            is_ssp = true;
            lat_name = lat_name_split[0] + ' ' + lat_name_split[1]; // remove subspecies
        }

        let is_research = (values[i_quality_grade] == "research");


        let obs = {
            obs_id: values[i_id],
            user_id: values[i_user_login],
            time: observed_time,
            url: values[i_url],
            is_research: is_research,
            is_ssp: is_ssp,
            lat_name: values[i_lat_name],
        };

        
        let card;
        
        if( !speciesMap.has(lat_name) )
        {
            card = {
                lat_name: lat_name,
                name: values[i_lang_name],
                total_observed: 0,
                total_research: 0,
                first_observed: obs,
                last_observed:  obs,
                ssps: new Map(),
                observations: new Array(),
            };

            speciesMap.set(lat_name, card);
        }
        else
        {
            card = speciesMap.get(lat_name);
        }

        card.observations.push( obs );
        card.total_observed += 1;
        card.total_research += (is_research)?1:0;

        if( !is_hybrid && !is_ssp && card.name != values[i_lang_name] )
        {
            card.name = values[i_lang_name];
        }

        
        if( observed_time < card.first_observed.time )
        {
            card.first_observed = obs;
        }

        if( observed_time > card.last_observed.time )
        {
            card.last_observed = obs;
        }

        if( is_research )
        {
            if( typeof card.first_research === "undefined" || observed_time < card.first_research.time )
            {
                card.first_research = obs;
            }
        }

        if( is_ssp )
        {
            obs.lat_name = Array.from(lat_name_split[0])[0] + '.' + Array.from(lat_name_split[1])[0] + '. ' + lat_name_split[2];
            if( card.ssps.has(obs.lat_name) )
            {
                num = card.ssps.get(obs.lat_name);
                num += 1;
                card.ssps.set(obs.lat_name, num);
            }
            else
            {
                card.ssps.set(obs.lat_name, 1);
            }
        }
    }

    console.log('Total species: ' + speciesMap.size);

    return speciesMap;
}

</script>

<script>

function generateYearsTable( speciesMap )
{
    const speciesYearsMap = new Map();

    speciesMap.forEach( (value, key) =>
    {
        const card = value;
        let year = card.first_observed.time.getFullYear();

        if( !speciesYearsMap.has(year) )
        {
            speciesYearsMap.set(year, []);
        }

        speciesYearsMap.get(year).push(value);
    } );

    const speciesYearsMapSorted = new Map([...speciesYearsMap].sort());

    {
        const instruction = document.getElementById("instruction");
        instruction.innerHTML = '';
        const table_years = document.getElementById("table_years");
        table_years.innerHTML = '';

        table_years.appendChild(createTr(
                    ['rowspan',2,'year'], ['colspan',2,'number of species'], ['colspan',2,'names'], ['colspan',3,'all years'],
                    ['colspan',2,'first observation'],
                    ['colspan',3,'first research grade if different']));

        table_years.appendChild(createTr(
                    'cumulative', 'this year', 'common', 'latin (clickable)', 'obs', 'rsch','ssps',
                    'ref', 'user', 'year', 'ref', 'user'));

        let cumulative = 0;
        speciesYearsMapSorted.forEach( (value, key) =>
        {

            const cards = value;
            cumulative += cards.length;

            let first = true;

            
            cards.forEach( (card) => 
            {

                let name = card.name;
                let lat_name = document.createElement("span");

                lat_name.addEventListener("click", (event) => {
                    generateSpeciesDetail( card );
                });

                lat_name.innerHTML = card.lat_name;
                let total    = card.total_observed;
                let research = card.total_research;

                let fst_url  = card.first_observed.url;
                let fst_href = `<a href='${fst_url}'>link</a>`;
                let fst_user = card.first_observed.user_id;

                let lst_url  = card.last_observed.url;
                let lst_href = `<a href='${lst_url}'>link</a>`;
                let lst_year = card.last_observed.time.getFullYear();


                let first_is_research = card.first_observed.is_research;
                let has_research = typeof card.first_research !== "undefined";
                let rsch_url  = (first_is_research)?'':(!has_research)?'':card.first_research.url;
                let rsch_href = (first_is_research)?'':(!has_research)?'':`<a href='${rsch_url}'>link</a>`;
                let rsch_user = (first_is_research)?'':(!has_research)?'':card.first_research.user_id;
                let rsch_year = (first_is_research)?'':(!has_research)?'none':card.first_research.time.getFullYear();

                let ssps_text = '';
                if( card.ssps.size > 0 )
                {
                    card.ssps.forEach( (num, ssp) => 
                    {
                        ssps_text += ssp + ' - ' + num + '<br/>';
                    });
                }

                if(first)
                {
                    let tr = createTr(['rowspan',cards.length,key], ['rowspan',cards.length,cumulative], ['rowspan',cards.length,cards.length],
                        name, lat_name, total, research, ssps_text, fst_href, fst_user, rsch_year, rsch_href, rsch_user);
                    table_years.appendChild(tr);
                }
                else
                {
                    let tr = createTr(
                        name, lat_name, total, research, ssps_text, fst_href, fst_user, rsch_year, rsch_href, rsch_user);
                    table_years.appendChild(tr);
                }
                
                first = false;
            } );
        } );
    }
}

</script>

<script>

function generateSpeciesDetail( card )
{
    let monthsN = [0,0,0, 0,0,0, 0,0,0, 0,0,0]; 
    let yearsMap = new Map();

    card.observations.forEach(( obs ) => 
    {
        monthsN[ obs.time.getMonth() ] += 1;

        let year = obs.time.getFullYear();
        let year_value = 1;

        if( yearsMap.has(year) )
        {
            year_value = yearsMap.get(year) + 1;
        }

        yearsMap.set(year, year_value);
    } );

    yearsMap = new Map([...yearsMap].sort());

    const output = document.getElementById("output");
    output.innerHTML = card.name + ' (' + card.lat_name + ')';

    let monthGraphCanvas = document.createElement("canvas");
    output.appendChild( monthGraphCanvas );

    output.appendChild( document.createElement("br") );

    let yearGraphCanvas = document.createElement("canvas");
    output.appendChild( yearGraphCanvas );

    new Chart(monthGraphCanvas, {
        type: 'bar',
        data: {
          labels: ['J', 'F', 'M', 'A', 'M', 'J', 'J', 'A', 'S', 'O', 'N', 'D'],
          datasets: [{
            label: '#',
            data: monthsN,
            borderWidth: 1
          }]
        },
        options: {
          scales: {
            y: { beginAtZero: true }
          }
        }
      });

    new Chart(yearGraphCanvas, {
        type: 'bar',
        data: {
          labels: [ ...yearsMap.keys() ],
          datasets: [{
            label: '#',
            data: [ ...yearsMap.values() ],
            borderWidth: 1
          }]
        },
        options: {
          scales: {
            y: { beginAtZero: true }
          }
        }
      });

}

</script>

   
   <script>
      function createTr() {
        let tr = document.createElement("tr");

        for (var i = 0; i < arguments.length; i++) {
            let td = document.createElement("td");
            
            if( arguments[i] instanceof HTMLElement )
            {
                td.appendChild( arguments[i] );
            }
            else if( Array.isArray(arguments[i]) )
            {
                td.setAttribute(arguments[i][0], arguments[i][1]);
                td.innerHTML = arguments[i][2];
            }
            else
            {
                td.innerHTML = arguments[i];
            }
            
            tr.appendChild( td );
        }

        return tr;
      }
      
      const myForm = document.getElementById("myForm");
      const csvFile = document.getElementById("csvFile");
      myForm.addEventListener("submit", function (e) {
         e.preventDefault();
         const input = csvFile.files[0];
         const reader = new FileReader();
         reader.onload = function (e) {
            const string = e.target.result;

            const speciesMap = CSV2SpeciesMap(string);

            generateYearsTable( speciesMap );
            


         };
         reader.readAsText(input);

      });
   </script>
</body>
</html>
