<!DOCTYPE html>
<html>
<head>
   <meta charset="UTF-8">

   <style>
        table, th, td {
          border: 1px solid;
        }
table {
  border-collapse: collapse;
}
   </style>
</head>
<body>

<div id="instruction">
Any options here, then press red-circled link.<br />
   <img width=600 src="img/first.jpeg" /><br /><br />
Green-circled options are required, red-circled options should be avoided (parsing do not correctly work with "," and "/n").<br />
   <img width=600 src="img/second.png" /><br /><br />
Waiting for archive to be available.<br />
Download archive, unpack it...<br />
Provide results CSV file to the form:<br />
</div>

   <form id="myForm">
      <input type="file" id="csvFile" accept=".csv" />
      <br />
      <input type="submit" value="Process" />
      <div id="output"/>
      <table id="table_years"></table>
   </form>
   <script>
      function createTr() {
        let tr = document.createElement("tr");

        for (var i = 0; i < arguments.length; i++) {
            let td = document.createElement("td");
            
            if( arguments[i] instanceof HTMLElement )
            {
                td.appendChild( arguments[i] );
            }
            else if( Array.isArray(arguments[i]) )
            {
                td.setAttribute(arguments[i][0], arguments[i][1]);
                td.innerHTML = arguments[i][2];
            }
            else
            {
                td.innerHTML = arguments[i];
            }
            
            tr.appendChild( td );
        }

        return tr;
      }
      
      const myForm = document.getElementById("myForm");
      const csvFile = document.getElementById("csvFile");
      myForm.addEventListener("submit", function (e) {
         e.preventDefault();
         const input = csvFile.files[0];
         const reader = new FileReader();
         reader.onload = function (e) {
            const string = e.target.result;


            var lines = string.split("\n");

            var headers = lines[0].split(",");
            lines.shift();

            const output = document.getElementById("output");

            const knownHeaderName = [ "user_login",  "url", "time_observed_at", "scientific_name", "common_name", "quality_grade", "observed_on", "id"];
            let   knownHeaderIdx  = [];
            
            for (let i = 0; i < headers.length; i++) {
                for (let j = 0; j < knownHeaderName.length; j++) {
                    if(headers[i] == knownHeaderName[j]) {
                        knownHeaderIdx[j] = i;
                    }
                }
            }
            const i_user_login   =knownHeaderIdx[0];
            const i_url          =knownHeaderIdx[1];
            const i_time_observed=knownHeaderIdx[2];
            const i_lat_name     =knownHeaderIdx[3];
            const i_lang_name    =knownHeaderIdx[4];
            const i_quality_grade=knownHeaderIdx[5];
            const i_observed_on  =knownHeaderIdx[6];
            const i_id           =knownHeaderIdx[7];
            console.log(knownHeaderIdx);

            const speciesMap = new Map();


            for(let i = 0; i < lines.length; i++) {
                /// Beware: `description` can be multiline and may contain ","
                /// Beware: `tag_list` may contain ","

                const values = lines[i].split(",");

                let lat_name = values[i_lat_name];
                let observed_time = new Date(values[i_observed_on]);

                if(values.length == 1)
                {
                    console.log("last line");
                    break;
                }
                if(values.length != headers.length)
                {
                    console.log(values);
                    console.log("broken line");
                    continue;
                }
                
                let lat_name_split = lat_name.split(" ");
                
                let is_identified = (lat_name_split.length >= 2);
                if(!is_identified) continue;

                if(lat_name_split.length > 2)
                {
                    lat_name = lat_name_split[0] + ' ' + lat_name_split[1]; // remove subspecies
                }

                let is_research = (values[i_quality_grade] == "research");

                if( !speciesMap.has(lat_name) )
                {
                    let card = {
                        lat_name: lat_name,
                        name: values[i_lang_name],
                        total_observed: 1,
                        total_observed_research: (is_research)?1:0,
                        first_observed_user_id: values[i_user_login],
                        first_observed_time: observed_time,
                        first_observed_url: values[i_url],
                        first_observed_id: values[i_id],
                    };
                    if( is_research )
                    {
                        card.first_observed_research_user_id = values[i_user_login];
                        card.first_observed_research_time = observed_time;
                        card.first_observed_research_url = values[i_url];
                        card.first_observed_research_id = values[i_id];
                    }

                    speciesMap.set(lat_name, card);
                }
                else
                {
                    let card = speciesMap.get(lat_name);
                    card.total_observed += 1;
                    card.total_observed_research += (is_research)?1:0;

                    if( observed_time < card.first_observed_time )
                    {
                        card.first_observed_user_id = values[i_user_login];
                        card.first_observed_time = observed_time;
                        card.first_observed_url = values[i_url];
                        card.first_observed_id = values[i_id];
                    }

                    if( is_research )
                    {
                        if( typeof card.first_observed_research_time === "undefined" || observed_time < card.first_observed_research_time )
                        {
                            card.first_observed_research_user_id = values[i_user_login];
                            card.first_observed_research_time = observed_time;
                            card.first_observed_research_url = values[i_url];
                            card.first_observed_research_id = values[i_id];
                        }

                    }
                }
            }

            console.log('Total species: ' + speciesMap.size);

            const speciesYearsMap = new Map();

            speciesMap.forEach( (value, key) =>
            {
                const card = value;
                let year = card.first_observed_time.getFullYear();

                if( !speciesYearsMap.has(year) )
                {
                    speciesYearsMap.set(year, []);
                }

                speciesYearsMap.get(year).push(value);
            } );

            const speciesYearsMapSorted = new Map([...speciesYearsMap].sort());

            {
                const instruction = document.getElementById("instruction");
                instruction.innerHTML = '';
                const table_years = document.getElementById("table_years");
                table_years.innerHTML = '';

                table_years.appendChild(createTr(
                            ['rowspan',2,'year'], ['colspan',2,'number of species'], ['colspan',2,'names'], ['rowspan',2,'all years num'],
                            ['colspan',2,'first observation'],
                            ['colspan',3,'first research grade if different']));

                table_years.appendChild(createTr(
                            'cumulative', 'this year', 'common', 'latin',
                            'ref', 'user', 'year', 'ref', 'user'));

                let cumulative = 0;
                speciesYearsMapSorted.forEach( (value, key) =>
                {

                    const cards = value;
                    cumulative += cards.length;

                    let first = true;

                    
                    cards.forEach( (card) => 
                    {

                        let name = card.name;
                        let lat_name = '(' + card.lat_name + ')';
                        let fst_url  = card.first_observed_url;
                        let fst_href = `<a href='${fst_url}'>link</a>`;
                        let fst_user = card.first_observed_user_id;
                        let total    = card.total_observed;

                        let first_is_research = card.first_observed_id==card.first_observed_research_id;
                        let has_research = typeof card.first_observed_research_id !== "undefined";
                        let rsch_url  = (first_is_research)?'':(!has_research)?'':card.first_observed_research_url;
                        let rsch_href = (first_is_research)?'':(!has_research)?'':`<a href='${rsch_url}'>link</a>`;
                        let rsch_user = (first_is_research)?'':(!has_research)?'':card.first_observed_research_user_id;
                        let rsch_year = (first_is_research)?'':(!has_research)?'none':card.first_observed_research_time.getFullYear();

                        if(first)
                        {
                            let tr = createTr(['rowspan',cards.length,key], ['rowspan',cards.length,cumulative], ['rowspan',cards.length,cards.length],
                                name, lat_name, total, fst_href, fst_user, rsch_year, rsch_href, rsch_user);
                            table_years.appendChild(tr);
                        }
                        else
                        {
                            let tr = createTr(
                                name, lat_name, total, fst_href, fst_user, rsch_year, rsch_href, rsch_user);
                            table_years.appendChild(tr);
                        }
                        
                        first = false;
                    } );

                    //let tr = createTr(key, cards.length, cumulative, text, table);
                    //table_years.appendChild(tr);
                } );
            }


         };
         reader.readAsText(input);

      });
   </script>
</body>
</html>
