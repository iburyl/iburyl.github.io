<!DOCTYPE html>
<html>
<head>
   <meta charset="UTF-8">

   <style>
        table, th, td {
          border: 1px solid;
        }
table {
  border-collapse: collapse;
}
   </style>
</head>
<body>

<div id="instruction">
Any options here, then press red-circled link.<br />
   <img width=600 src="img/first.jpeg" /><br /><br />
Green-circled options are required, red-circled options should be avoided (the issues with those are fixed, but be cautious just in case).<br />
   <img width=600 src="img/second.png" /><br /><br />
Waiting for archive to be available.<br />
Download archive, unpack it...<br />
Provide results CSV file to the form:<br />
</div>

   <form id="myForm">
      <input type="file" id="csvFile" accept=".csv" />
      <br />
      <input type="submit" value="Process" />
      <div id="output"/>
      <table id="table_years"></table>
   </form>

<script type="text/javascript">
    // Source for this one is: https://www.bennadel.com/blog/1504-ask-ben-parsing-csv-strings-with-javascript-exec-regular-expression-command.htm
	
    // This will parse a delimited string into an array of
	// arrays. The default delimiter is the comma, but this
	// can be overriden in the second argument.
	function CSVToArray( strData, strDelimiter ){
		// Check to see if the delimiter is defined. If not,
		// then default to comma.
		strDelimiter = (strDelimiter || ",");

		// Create a regular expression to parse the CSV values.
		var objPattern = new RegExp(
			(
				// Delimiters.
				"(\\" + strDelimiter + "|\\r?\\n|\\r|^)" +

				// Quoted fields.
				"(?:\"([^\"]*(?:\"\"[^\"]*)*)\"|" +

				// Standard fields.
				"([^\"\\" + strDelimiter + "\\r\\n]*))"
			),
			"gi"
			);


		// Create an array to hold our data. Give the array
		// a default empty first row.
		var arrData = [[]];

		// Create an array to hold our individual pattern
		// matching groups.
		var arrMatches = null;


		// Keep looping over the regular expression matches
		// until we can no longer find a match.
		while (arrMatches = objPattern.exec( strData )){

			// Get the delimiter that was found.
			var strMatchedDelimiter = arrMatches[ 1 ];

			// Check to see if the given delimiter has a length
			// (is not the start of string) and if it matches
			// field delimiter. If id does not, then we know
			// that this delimiter is a row delimiter.
			if (
				strMatchedDelimiter.length &&
				(strMatchedDelimiter != strDelimiter)
				){

				// Since we have reached a new row of data,
				// add an empty row to our data array.
				arrData.push( [] );

			}


			// Now that we have our delimiter out of the way,
			// let's check to see which kind of value we
			// captured (quoted or unquoted).
			if (arrMatches[ 2 ]){

				// We found a quoted value. When we capture
				// this value, unescape any double quotes.
				var strMatchedValue = arrMatches[ 2 ].replace(
					new RegExp( "\"\"", "g" ),
					"\""
					);

			} else {

				// We found a non-quoted value.
				var strMatchedValue = arrMatches[ 3 ];

			}


			// Now that we have our value string, let's add
			// it to the data array.
			arrData[ arrData.length - 1 ].push( strMatchedValue );
		}

		// Return the parsed data.
		return( arrData );
	}

</script>
   
   <script>
      function createTr() {
        let tr = document.createElement("tr");

        for (var i = 0; i < arguments.length; i++) {
            let td = document.createElement("td");
            
            if( arguments[i] instanceof HTMLElement )
            {
                td.appendChild( arguments[i] );
            }
            else if( Array.isArray(arguments[i]) )
            {
                td.setAttribute(arguments[i][0], arguments[i][1]);
                td.innerHTML = arguments[i][2];
            }
            else
            {
                td.innerHTML = arguments[i];
            }
            
            tr.appendChild( td );
        }

        return tr;
      }
      
      const myForm = document.getElementById("myForm");
      const csvFile = document.getElementById("csvFile");
      myForm.addEventListener("submit", function (e) {
         e.preventDefault();
         const input = csvFile.files[0];
         const reader = new FileReader();
         reader.onload = function (e) {
            const string = e.target.result;

            const CSVarrays = CSVToArray(string);
            
            var headers = CSVarrays[0];
            CSVarrays.shift();

            const output = document.getElementById("output");

            const knownHeaderName = [ "user_login",  "url", "time_observed_at", "scientific_name", "common_name", "quality_grade", "observed_on", "id"];
            let   knownHeaderIdx  = [];
            
            for (let i = 0; i < headers.length; i++) {
                for (let j = 0; j < knownHeaderName.length; j++) {
                    if(headers[i] == knownHeaderName[j]) {
                        knownHeaderIdx[j] = i;
                    }
                }
            }
            const i_user_login   =knownHeaderIdx[0];
            const i_url          =knownHeaderIdx[1];
            const i_time_observed=knownHeaderIdx[2];
            const i_lat_name     =knownHeaderIdx[3];
            const i_lang_name    =knownHeaderIdx[4];
            const i_quality_grade=knownHeaderIdx[5];
            const i_observed_on  =knownHeaderIdx[6];
            const i_id           =knownHeaderIdx[7];
            console.log(knownHeaderIdx);

            const speciesMap = new Map();

            console.log('Total observations: ' + CSVarrays.length);

            for(let i = 0; i < CSVarrays.length; i++) {
                const values = CSVarrays[i];

                let lat_name = values[i_lat_name];
                let observed_time = new Date(values[i_observed_on]);

                if(values.length == 1)
                {
                    console.log("last line");
                    break;
                }
                if(values.length != headers.length)
                {
                    console.log(values);
                    console.log("broken line");
                    continue;
                }
                
                let lat_name_split = lat_name.split(" ");
                
                let is_identified = (lat_name_split.length >= 2);
                if(!is_identified) continue;

                if(lat_name_split.length > 2)
                {
                    lat_name = lat_name_split[0] + ' ' + lat_name_split[1]; // remove subspecies
                }

                let is_research = (values[i_quality_grade] == "research");

                if( !speciesMap.has(lat_name) )
                {
                    let card = {
                        lat_name: lat_name,
                        name: values[i_lang_name],
                        total_observed: 1,
                        total_observed_research: (is_research)?1:0,
                        first_observed_user_id: values[i_user_login],
                        first_observed_time: observed_time,
                        first_observed_url: values[i_url],
                        first_observed_id: values[i_id],
                    };
                    if( is_research )
                    {
                        card.first_observed_research_user_id = values[i_user_login];
                        card.first_observed_research_time = observed_time;
                        card.first_observed_research_url = values[i_url];
                        card.first_observed_research_id = values[i_id];
                    }

                    speciesMap.set(lat_name, card);
                }
                else
                {
                    let card = speciesMap.get(lat_name);
                    card.total_observed += 1;
                    card.total_observed_research += (is_research)?1:0;

                    if( observed_time < card.first_observed_time )
                    {
                        card.first_observed_user_id = values[i_user_login];
                        card.first_observed_time = observed_time;
                        card.first_observed_url = values[i_url];
                        card.first_observed_id = values[i_id];
                    }

                    if( is_research )
                    {
                        if( typeof card.first_observed_research_time === "undefined" || observed_time < card.first_observed_research_time )
                        {
                            card.first_observed_research_user_id = values[i_user_login];
                            card.first_observed_research_time = observed_time;
                            card.first_observed_research_url = values[i_url];
                            card.first_observed_research_id = values[i_id];
                        }

                    }
                }
            }

            console.log('Total species: ' + speciesMap.size);

            const speciesYearsMap = new Map();

            speciesMap.forEach( (value, key) =>
            {
                const card = value;
                let year = card.first_observed_time.getFullYear();

                if( !speciesYearsMap.has(year) )
                {
                    speciesYearsMap.set(year, []);
                }

                speciesYearsMap.get(year).push(value);
            } );

            const speciesYearsMapSorted = new Map([...speciesYearsMap].sort());

            {
                const instruction = document.getElementById("instruction");
                instruction.innerHTML = '';
                const table_years = document.getElementById("table_years");
                table_years.innerHTML = '';

                table_years.appendChild(createTr(
                            ['rowspan',2,'year'], ['colspan',2,'number of species'], ['colspan',2,'names'], ['rowspan',2,'all years num'],
                            ['colspan',2,'first observation'],
                            ['colspan',3,'first research grade if different']));

                table_years.appendChild(createTr(
                            'cumulative', 'this year', 'common', 'latin',
                            'ref', 'user', 'year', 'ref', 'user'));

                let cumulative = 0;
                speciesYearsMapSorted.forEach( (value, key) =>
                {

                    const cards = value;
                    cumulative += cards.length;

                    let first = true;

                    
                    cards.forEach( (card) => 
                    {

                        let name = card.name;
                        let lat_name = '(' + card.lat_name + ')';
                        let fst_url  = card.first_observed_url;
                        let fst_href = `<a href='${fst_url}'>link</a>`;
                        let fst_user = card.first_observed_user_id;
                        let total    = card.total_observed;

                        let first_is_research = card.first_observed_id==card.first_observed_research_id;
                        let has_research = typeof card.first_observed_research_id !== "undefined";
                        let rsch_url  = (first_is_research)?'':(!has_research)?'':card.first_observed_research_url;
                        let rsch_href = (first_is_research)?'':(!has_research)?'':`<a href='${rsch_url}'>link</a>`;
                        let rsch_user = (first_is_research)?'':(!has_research)?'':card.first_observed_research_user_id;
                        let rsch_year = (first_is_research)?'':(!has_research)?'none':card.first_observed_research_time.getFullYear();

                        if(first)
                        {
                            let tr = createTr(['rowspan',cards.length,key], ['rowspan',cards.length,cumulative], ['rowspan',cards.length,cards.length],
                                name, lat_name, total, fst_href, fst_user, rsch_year, rsch_href, rsch_user);
                            table_years.appendChild(tr);
                        }
                        else
                        {
                            let tr = createTr(
                                name, lat_name, total, fst_href, fst_user, rsch_year, rsch_href, rsch_user);
                            table_years.appendChild(tr);
                        }
                        
                        first = false;
                    } );

                    //let tr = createTr(key, cards.length, cumulative, text, table);
                    //table_years.appendChild(tr);
                } );
            }


         };
         reader.readAsText(input);

      });
   </script>
</body>
</html>
